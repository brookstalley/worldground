<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Worldground Viewer</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #1a1a2e; color: #e0e0e0; font-family: 'Segoe UI', system-ui, sans-serif; overflow: hidden; }

#app { display: flex; height: 100vh; }

#canvas-container {
  flex: 1;
  position: relative;
  overflow: hidden;
  cursor: grab;
}
#canvas-container.dragging { cursor: grabbing; }

canvas {
  display: block;
  position: absolute;
  top: 0;
  left: 0;
}

#sidebar {
  width: 280px;
  background: #16213e;
  border-left: 1px solid #0f3460;
  padding: 16px;
  overflow-y: auto;
  flex-shrink: 0;
}

#sidebar h2 {
  font-size: 14px;
  color: #e94560;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 12px;
}

#sidebar h3 {
  font-size: 12px;
  color: #888;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin: 16px 0 8px;
}

.stat-row {
  display: flex;
  justify-content: space-between;
  padding: 4px 0;
  font-size: 13px;
}
.stat-row .label { color: #aaa; }
.stat-row .value { color: #fff; font-variant-numeric: tabular-nums; }

.biome-bar {
  display: flex;
  height: 20px;
  border-radius: 4px;
  overflow: hidden;
  margin: 4px 0 8px;
}

.biome-segment { transition: width 0.3s ease; }

.biome-legend {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  font-size: 11px;
}
.biome-legend-item {
  display: flex;
  align-items: center;
  gap: 3px;
}
.biome-legend-swatch {
  width: 10px;
  height: 10px;
  border-radius: 2px;
}

#connection-status {
  padding: 6px 10px;
  border-radius: 4px;
  font-size: 12px;
  margin-bottom: 12px;
  text-align: center;
}
.status-connected { background: #0f5132; color: #75b798; }
.status-disconnected { background: #842029; color: #ea868f; }
.status-connecting { background: #664d03; color: #ffda6a; }

#tile-info {
  background: #1a1a2e;
  border-radius: 4px;
  padding: 10px;
  font-size: 12px;
  margin-top: 12px;
  display: none;
}
#tile-info.visible { display: block; }
#tile-info .layer-title {
  color: #e94560;
  font-size: 11px;
  text-transform: uppercase;
  margin-top: 8px;
}
#tile-info .layer-title:first-child { margin-top: 0; }

#color-mode {
  margin-top: 12px;
  font-size: 12px;
}
#color-mode select {
  width: 100%;
  padding: 4px 8px;
  background: #1a1a2e;
  color: #e0e0e0;
  border: 1px solid #0f3460;
  border-radius: 4px;
  margin-top: 4px;
}
</style>
</head>
<body>
<div id="app">
  <div id="canvas-container">
    <canvas id="hex-canvas"></canvas>
  </div>
  <div id="sidebar">
    <h2>Worldground</h2>
    <div id="connection-status" class="status-connecting">Connecting...</div>

    <div class="stat-row"><span class="label">Tick</span><span class="value" id="stat-tick">-</span></div>
    <div class="stat-row"><span class="label">Season</span><span class="value" id="stat-season">-</span></div>
    <div class="stat-row"><span class="label">Tiles</span><span class="value" id="stat-tiles">-</span></div>
    <div class="stat-row"><span class="label">Topology</span><span class="value" id="stat-topology">-</span></div>
    <div class="stat-row"><span class="label">Diversity</span><span class="value" id="stat-diversity">-</span></div>
    <div class="stat-row"><span class="label">Avg Temp</span><span class="value" id="stat-temp">-</span></div>
    <div class="stat-row"><span class="label">Avg Moisture</span><span class="value" id="stat-moisture">-</span></div>
    <div class="stat-row"><span class="label">Tick Time</span><span class="value" id="stat-tickms">-</span></div>
    <div class="stat-row"><span class="label">Rule Errors</span><span class="value" id="stat-errors">-</span></div>

    <h3>Biome Distribution</h3>
    <div class="biome-bar" id="biome-bar"></div>
    <div class="biome-legend" id="biome-legend"></div>

    <div id="color-mode">
      <label>Color by:</label>
      <select id="color-select">
        <option value="biome" selected>Biome</option>
        <option value="elevation">Elevation</option>
        <option value="temperature">Temperature</option>
        <option value="moisture">Soil Moisture</option>
        <option value="vegetation">Vegetation Health</option>
        <option value="terrain">Terrain Type</option>
        <option value="clouds">Cloud Cover</option>
        <option value="precipitation">Precipitation</option>
        <option value="humidity">Humidity</option>
        <option value="wind">Wind Speed</option>
        <option value="storms">Storm Intensity</option>
        <option value="pressure">Pressure</option>
      </select>
    </div>

    <div id="weather-toggle" style="margin-top:12px; font-size:12px;">
      <label><input type="checkbox" id="weather-enabled" checked> Weather layer</label>
    </div>

    <div id="view-mode" style="display:none; margin-top:12px; font-size:12px;">
      <label>View:</label>
      <select id="view-select" style="width:100%;padding:4px 8px;background:#1a1a2e;color:#e0e0e0;border:1px solid #0f3460;border-radius:4px;margin-top:4px;">
        <option value="map" selected>Map</option>
        <option value="globe">Globe</option>
      </select>
    </div>

    <div id="tile-info">
      <div class="layer-title">Selected Tile</div>
      <div id="tile-detail"></div>
    </div>
  </div>
</div>

<script>
// ============================================================
// Biome & terrain color maps
// ============================================================
const BIOME_COLORS = {
  Ocean: '#1a5276',
  Ice: '#dce6f0',
  Tundra: '#b8c6d0',
  BorealForest: '#4a6741',
  TemperateForest: '#2d6a30',
  Grassland: '#7daf4b',
  Savanna: '#c4a747',
  Desert: '#f0d68a',
  TropicalForest: '#145a32',
  Wetland: '#5a7a5a',
  Barren: '#8b8b8b',
};

const TERRAIN_COLORS = {
  Ocean: '#0d3559',
  Coast: '#5da0c2',
  Plains: '#6db36d',
  Hills: '#a8a060',
  Mountains: '#8b8b8b',
  Cliffs: '#7a6b5d',
  Wetlands: '#4a7a6a',
};

// ============================================================
// State
// ============================================================
let tiles = {};          // id -> tile data
let tilePositions = {};  // id -> {x, y}
let tilePolygons = {};   // id -> [[x,y], ...] Voronoi cell vertices (geodesic only)
let gridWidth = 0;
let gridHeight = 0;
let hexSize = 12;        // pixels per hex unit
let renderHexSize = 12;  // actual rendering size (scales for geodesic)

let viewOffsetX = 0;
let viewOffsetY = 0;
let zoom = 1;
let isDragging = false;
let dragStartX = 0;
let dragStartY = 0;
let dragStartOffsetX = 0;
let dragStartOffsetY = 0;
let selectedTile = null;
let colorMode = 'biome';
let topologyType = 'FlatHex';

// Globe view state
let viewMode = 'map';          // 'map' or 'globe'
let globeRotLon = 0;           // degrees, drag left/right
let globeRotLat = 20;          // degrees, drag up/down, clamped ±89
let dragStartRotLon = 0;
let dragStartRotLat = 0;
let geoScaleValue = 0;         // saved geoScale from handleSnapshot
let equirectCanvas = null;     // offscreen canvas for texture
let equirectData = null;       // cached ImageData pixels
let textureDirty = true;       // re-render flag

// Weather texture state (separate layer for earth-from-space view)
const WTEX_W = 1024;
const WTEX_H = 512;
let weatherCanvas = null;
let weatherData = null;       // cached ImageData pixels
let weatherDirty = true;
let weatherEnabled = true;

let pressureSystems = [];  // [{id, lat, lon, pressure_anomaly, radius, system_type, moisture}]
let stats = {};
let ws = null;

// ============================================================
// Canvas setup
// ============================================================
const canvas = document.getElementById('hex-canvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('canvas-container');

function resizeCanvas() {
  canvas.width = container.clientWidth;
  canvas.height = container.clientHeight;
  render();
}
window.addEventListener('resize', resizeCanvas);

// ============================================================
// Hex math (pointy-top)
// ============================================================
function hexCorner(cx, cy, size, i) {
  const angle = Math.PI / 180 * (60 * i - 30);
  return [cx + size * Math.cos(angle), cy + size * Math.sin(angle)];
}

function drawHex(cx, cy, size, fillColor, strokeColor) {
  ctx.beginPath();
  for (let i = 0; i < 6; i++) {
    const [hx, hy] = hexCorner(cx, cy, size, i);
    if (i === 0) ctx.moveTo(hx, hy);
    else ctx.lineTo(hx, hy);
  }
  ctx.closePath();
  ctx.fillStyle = fillColor;
  ctx.fill();
  if (strokeColor) {
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 0.5;
    ctx.stroke();
  }
}

// ============================================================
// Voronoi cells for geodesic tiles
// ============================================================
function computeVoronoiCells() {
  tilePolygons = {};
  const ids = Object.keys(tilePositions);
  const n = ids.length;
  if (n === 0) return;

  // Build arrays for real tiles
  const xs = new Float64Array(n);
  const ys = new Float64Array(n);
  for (let i = 0; i < n; i++) {
    xs[i] = tilePositions[ids[i]].sx;
    ys[i] = tilePositions[ids[i]].sy;
  }

  // For geodesic: add ghost copies at ±worldWidth so tiles near the
  // antimeridian (lon ±180°) see their wrapped neighbors correctly.
  const worldWidth = 360 * geoScaleValue;
  const isGeodesic = topologyType === 'Geodesic' && worldWidth > 0;
  let allXs = xs, allYs = ys, totalN = n;

  if (isGeodesic) {
    const wrapMargin = worldWidth * 0.15;
    const ghostXs = [];
    const ghostYs = [];
    for (let i = 0; i < n; i++) {
      if (xs[i] < wrapMargin) {
        ghostXs.push(xs[i] + worldWidth);
        ghostYs.push(ys[i]);
      }
      if (xs[i] > worldWidth - wrapMargin) {
        ghostXs.push(xs[i] - worldWidth);
        ghostYs.push(ys[i]);
      }
    }
    totalN = n + ghostXs.length;
    allXs = new Float64Array(totalN);
    allYs = new Float64Array(totalN);
    allXs.set(xs);
    allYs.set(ys);
    for (let i = 0; i < ghostXs.length; i++) {
      allXs[n + i] = ghostXs[i];
      allYs[n + i] = ghostYs[i];
    }
  }

  const K = Math.min(20, totalN - 1);

  // Only compute cells for real tiles (first n entries)
  for (let i = 0; i < n; i++) {
    const px = allXs[i], py = allYs[i];

    // Find K nearest from ALL positions (including ghosts)
    const dists = new Float64Array(totalN);
    for (let j = 0; j < totalN; j++) {
      const dx = px - allXs[j], dy = py - allYs[j];
      dists[j] = dx * dx + dy * dy;
    }
    dists[i] = Infinity; // exclude self

    // Partial sort: find K smallest distances
    const neighbors = [];
    const used = new Uint8Array(totalN);
    for (let k = 0; k < K; k++) {
      let minD = Infinity, minJ = -1;
      for (let j = 0; j < totalN; j++) {
        if (!used[j] && dists[j] < minD) { minD = dists[j]; minJ = j; }
      }
      if (minJ < 0) break;
      used[minJ] = 1;
      neighbors.push(minJ);
    }

    // Start with large bounding box
    const nearestDist = Math.sqrt(dists[neighbors[0]]);
    const maxR = nearestDist * 4;
    let poly = [
      [px - maxR, py - maxR],
      [px + maxR, py - maxR],
      [px + maxR, py + maxR],
      [px - maxR, py + maxR],
    ];

    // Clip against perpendicular bisector with each neighbor
    for (const j of neighbors) {
      const qx = allXs[j], qy = allYs[j];
      const mx = (px + qx) / 2, my = (py + qy) / 2;
      const nx = px - qx, ny = py - qy; // normal toward p
      poly = clipPolygonByLine(poly, mx, my, nx, ny);
      if (poly.length < 3) break;
    }

    tilePolygons[ids[i]] = poly;
  }
}

// Sutherland-Hodgman: clip polygon to half-plane {x : dot(x - m, n) >= 0}
function clipPolygonByLine(poly, mx, my, nx, ny) {
  const out = [];
  const len = poly.length;
  if (len < 3) return poly;

  for (let i = 0; i < len; i++) {
    const cx = poly[i][0], cy = poly[i][1];
    const ni = (i + 1) % len;
    const ex = poly[ni][0], ey = poly[ni][1];

    const cDot = (cx - mx) * nx + (cy - my) * ny;
    const eDot = (ex - mx) * nx + (ey - my) * ny;

    if (cDot >= 0) out.push(poly[i]);
    if ((cDot >= 0) !== (eDot >= 0)) {
      const t = cDot / (cDot - eDot);
      out.push([cx + t * (ex - cx), cy + t * (ey - cy)]);
    }
  }
  return out;
}

function drawPolygon(poly, fillColor, strokeColor) {
  if (poly.length < 3) return;
  ctx.beginPath();
  ctx.moveTo(poly[0][0], poly[0][1]);
  for (let i = 1; i < poly.length; i++) {
    ctx.lineTo(poly[i][0], poly[i][1]);
  }
  ctx.closePath();
  ctx.fillStyle = fillColor;
  ctx.fill();
  if (strokeColor) {
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 0.5;
    ctx.stroke();
  }
}

function pixelToTile(px, py) {
  // Convert screen pixel to world coordinates
  const wx = (px - viewOffsetX) / zoom;
  const wy = (py - viewOffsetY) / zoom;

  // Find closest tile center
  let closest = null;
  let closestDist = Infinity;
  for (const [id, pos] of Object.entries(tilePositions)) {
    const dx = wx - pos.sx;
    const dy = wy - pos.sy;
    const dist = dx * dx + dy * dy;
    if (dist < closestDist) {
      closestDist = dist;
      closest = parseInt(id);
    }
  }
  // For geodesic Voronoi, nearest center is always the correct cell.
  // For flat hex, require proximity to the hex.
  if (topologyType === 'Geodesic') return closest;
  if (closestDist < (renderHexSize * renderHexSize)) return closest;
  return null;
}

// ============================================================
// Color computation
// ============================================================
function getTileColor(tile) {
  switch (colorMode) {
    case 'biome':
      return BIOME_COLORS[tile.biome?.biome_type] || '#444';
    case 'terrain':
      return TERRAIN_COLORS[tile.geology?.terrain_type] || '#444';
    case 'elevation': {
      const e = tile.geology?.elevation ?? 0;
      const t = Math.max(0, Math.min(1, e));
      return `hsl(${200 - t * 200}, 60%, ${20 + t * 60}%)`;
    }
    case 'temperature': {
      const temp = tile.weather?.temperature ?? 273;
      const norm = Math.max(0, Math.min(1, (temp - 230) / 80));
      return `hsl(${240 - norm * 240}, 70%, ${30 + norm * 40}%)`;
    }
    case 'moisture': {
      const m = tile.conditions?.soil_moisture ?? 0;
      const v = Math.max(0, Math.min(1, m));
      return `hsl(${30 + v * 180}, 60%, ${25 + v * 40}%)`;
    }
    case 'vegetation': {
      const vh = tile.biome?.vegetation_health ?? 0;
      const vv = Math.max(0, Math.min(1, vh));
      return `hsl(${60 + vv * 60}, ${30 + vv * 50}%, ${20 + vv * 40}%)`;
    }
    case 'clouds': {
      const cc = tile.weather?.cloud_cover ?? 0;
      const v = Math.max(0, Math.min(1, cc));
      // Dark blue (clear) -> white (overcast)
      const l = 15 + v * 70;
      const s = 60 - v * 40;
      return `hsl(220, ${s}%, ${l}%)`;
    }
    case 'precipitation': {
      const p = tile.weather?.precipitation ?? 0;
      if (p < 0.01) return '#1a1a2e';
      const pt = tile.weather?.precipitation_type ?? 'None';
      const intensity = Math.max(0, Math.min(1, p * 3));
      if (pt === 'Snow') return `hsl(200, ${20 + intensity * 30}%, ${50 + intensity * 40}%)`;
      if (pt === 'Sleet') return `hsl(190, ${30 + intensity * 40}%, ${30 + intensity * 40}%)`;
      return `hsl(210, ${50 + intensity * 30}%, ${20 + intensity * 50}%)`;
    }
    case 'humidity': {
      const h = tile.weather?.humidity ?? 0;
      const v = Math.max(0, Math.min(1, h));
      // Brown (dry) -> green -> blue (wet)
      const hue = 30 + v * 190;
      return `hsl(${hue}, ${40 + v * 30}%, ${20 + v * 35}%)`;
    }
    case 'wind': {
      const ws = tile.weather?.wind_speed ?? 0;
      const v = Math.max(0, Math.min(1, ws / 15));
      // Green (calm) -> yellow -> red (strong)
      return `hsl(${120 - v * 120}, ${50 + v * 30}%, ${25 + v * 35}%)`;
    }
    case 'storms': {
      const si = tile.weather?.storm_intensity ?? 0;
      if (si < 0.02) return '#1a1a2e';
      const v = Math.max(0, Math.min(1, si));
      // Dark purple -> bright magenta
      return `hsl(${280 + v * 20}, ${40 + v * 50}%, ${15 + v * 55}%)`;
    }
    case 'pressure': {
      const p = tile.weather?.pressure ?? 1013.25;
      // Range: 980 hPa (deep low) to 1040 hPa (strong high)
      const norm = Math.max(0, Math.min(1, (p - 980) / 60));
      // Blue (low pressure) -> white (standard) -> red (high pressure)
      if (norm < 0.5) {
        const t = norm * 2; // 0..1 within low half
        const r = Math.round(40 + t * 215);
        const g = Math.round(80 + t * 175);
        const b = Math.round(220 + t * 35);
        return `rgb(${r},${g},${b})`;
      } else {
        const t = (norm - 0.5) * 2; // 0..1 within high half
        const r = Math.round(255 - t * 55);
        const g = Math.round(255 - t * 175);
        const b = Math.round(255 - t * 195);
        return `rgb(${r},${g},${b})`;
      }
    }
    default:
      return '#444';
  }
}

// ============================================================
// Rendering
// ============================================================
// ============================================================
// Weather RGBA per tile (earth-from-space cloud layer)
// ============================================================
function computeWeatherRGBA(tile) {
  if (!tile) return {r: 0, g: 0, b: 0, a: 0};

  const cc = tile.weather?.cloud_cover ?? 0;
  const si = tile.weather?.storm_intensity ?? 0;
  const precip = tile.weather?.precipitation ?? 0;
  const pt = tile.weather?.precipitation_type ?? 'None';

  if (cc < 0.02 && si < 0.02 && precip < 0.02) return {r: 0, g: 0, b: 0, a: 0};

  // Cloud color progression: thin cirrus → thick cumulus → storm
  let cr, cg, cb;
  if (si > 0.1) {
    // Storm: dark gray-purple, interpolate with intensity
    const t = Math.min(1, si);
    cr = 60 + (1 - t) * 160;
    cg = 55 + (1 - t) * 165;
    cb = 70 + (1 - t) * 155;
  } else if (cc > 0.6) {
    // Thick cumulus: gray-white
    cr = 220; cg = 220; cb = 225;
  } else {
    // Thin cirrus: bright white
    cr = 240; cg = 245; cb = 250;
  }

  // Opacity ramp: cc^1.5 makes moderate clouds more visible than cc^2
  let alpha = Math.pow(cc, 1.5);

  // Storm intensifies opacity
  if (si > 0.1) {
    alpha = Math.max(alpha, 0.3 + si * 0.5);
  }

  // Rain darkening
  if (precip > 0.05 && pt !== 'Snow') {
    const darkening = Math.min(0.3, precip * 0.8);
    cr *= (1 - darkening);
    cg *= (1 - darkening);
    cb *= (1 - darkening);
    alpha = Math.max(alpha, precip * 0.6);
  }

  // Snow brightening
  if (pt === 'Snow' && precip > 0.05) {
    cr = Math.min(255, cr + 20);
    cg = Math.min(255, cg + 20);
    cb = Math.min(255, cb + 15);
  }

  alpha = Math.max(0, Math.min(1, alpha));

  return {
    r: Math.round(cr),
    g: Math.round(cg),
    b: Math.round(cb),
    a: Math.round(alpha * 255)
  };
}

// ============================================================
// Weather texture (offscreen 1024x512 for globe atmosphere layer)
// ============================================================
function renderWeatherTexture() {
  if (!weatherDirty && weatherData) return;
  if (!geoScaleValue) return;

  if (!weatherCanvas) {
    weatherCanvas = document.createElement('canvas');
    weatherCanvas.width = WTEX_W;
    weatherCanvas.height = WTEX_H;
  }

  const wctx = weatherCanvas.getContext('2d');
  wctx.clearRect(0, 0, WTEX_W, WTEX_H);

  const scaleX = WTEX_W / (360 * geoScaleValue);
  const scaleY = WTEX_H / (180 * geoScaleValue);

  wctx.save();
  wctx.scale(scaleX, scaleY);

  // Draw per-tile weather
  for (const [id, pos] of Object.entries(tilePositions)) {
    const tile = tiles[id];
    if (!tile) continue;
    const poly = tilePolygons[id];
    if (!poly || poly.length < 3) continue;

    const wx = computeWeatherRGBA(tile);
    if (wx.a === 0) continue;

    wctx.beginPath();
    wctx.moveTo(poly[0][0], poly[0][1]);
    for (let i = 1; i < poly.length; i++) {
      wctx.lineTo(poly[i][0], poly[i][1]);
    }
    wctx.closePath();
    wctx.fillStyle = `rgba(${wx.r},${wx.g},${wx.b},${(wx.a / 255).toFixed(3)})`;
    wctx.fill();
  }

  // Wrapped copies for antimeridian seam
  const worldWidth = 360 * geoScaleValue;
  if (worldWidth > 0) {
    const wrapMargin = worldWidth * 0.15;
    for (const [id, pos] of Object.entries(tilePositions)) {
      const tile = tiles[id];
      if (!tile) continue;
      const poly = tilePolygons[id];
      if (!poly || poly.length < 3) continue;

      let shiftX = 0;
      if (pos.sx < wrapMargin) shiftX = worldWidth;
      else if (pos.sx > worldWidth - wrapMargin) shiftX = -worldWidth;
      else continue;

      const wx = computeWeatherRGBA(tile);
      if (wx.a === 0) continue;

      wctx.beginPath();
      wctx.moveTo(poly[0][0] + shiftX, poly[0][1]);
      for (let i = 1; i < poly.length; i++) {
        wctx.lineTo(poly[i][0] + shiftX, poly[i][1]);
      }
      wctx.closePath();
      wctx.fillStyle = `rgba(${wx.r},${wx.g},${wx.b},${(wx.a / 255).toFixed(3)})`;
      wctx.fill();
    }
  }

  // Pressure system radial gradients baked into weather texture
  for (const sys of pressureSystems) {
    const sx = (sys.lon + 180) * geoScaleValue;
    const sy = (90 - sys.lat) * geoScaleValue;
    const radiusPx = sys.radius * (180 / Math.PI) * geoScaleValue;
    const isLow = sys.pressure_anomaly < 0;
    const strength = Math.min(1, Math.abs(sys.pressure_anomaly) / 30);

    const gradient = wctx.createRadialGradient(sx, sy, 0, sx, sy, radiusPx);
    if (isLow) {
      gradient.addColorStop(0, `rgba(60, 100, 220, ${(0.2 * strength).toFixed(3)})`);
      gradient.addColorStop(1, 'rgba(60, 100, 220, 0)');
    } else {
      gradient.addColorStop(0, `rgba(220, 60, 60, ${(0.15 * strength).toFixed(3)})`);
      gradient.addColorStop(1, 'rgba(220, 60, 60, 0)');
    }

    wctx.beginPath();
    wctx.arc(sx, sy, radiusPx, 0, Math.PI * 2);
    wctx.fillStyle = gradient;
    wctx.fill();
  }

  wctx.restore();

  weatherData = wctx.getImageData(0, 0, WTEX_W, WTEX_H);
  weatherDirty = false;
}

// ============================================================
// Equirectangular texture (offscreen, for globe view)
// ============================================================
const TEX_W = 2048;
const TEX_H = 1024;

function renderEquirectTexture() {
  if (!textureDirty && equirectData) return;

  if (!equirectCanvas) {
    equirectCanvas = document.createElement('canvas');
    equirectCanvas.width = TEX_W;
    equirectCanvas.height = TEX_H;
  }

  const tctx = equirectCanvas.getContext('2d');
  tctx.clearRect(0, 0, TEX_W, TEX_H);

  // Draw ocean background
  tctx.fillStyle = BIOME_COLORS.Ocean;
  tctx.fillRect(0, 0, TEX_W, TEX_H);

  // Scale so that world coordinates (lon+180)*geoScale, (90-lat)*geoScale
  // map into the texture. geoScaleValue converts degrees to world px.
  // World spans: x=[0, 360*geoScale], y=[0, 180*geoScale]
  const scaleX = TEX_W / (360 * geoScaleValue);
  const scaleY = TEX_H / (180 * geoScaleValue);

  tctx.save();
  tctx.scale(scaleX, scaleY);

  for (const [id, pos] of Object.entries(tilePositions)) {
    const tile = tiles[id];
    if (!tile) continue;
    const poly = tilePolygons[id];
    if (!poly || poly.length < 3) continue;

    tctx.beginPath();
    tctx.moveTo(poly[0][0], poly[0][1]);
    for (let i = 1; i < poly.length; i++) {
      tctx.lineTo(poly[i][0], poly[i][1]);
    }
    tctx.closePath();
    tctx.fillStyle = getTileColor(tile);
    tctx.fill();
  }

  // Wrapped copies for antimeridian seam
  const worldWidth = 360 * geoScaleValue;
  if (worldWidth > 0) {
    const wrapMargin = worldWidth * 0.15;
    for (const [id, pos] of Object.entries(tilePositions)) {
      const tile = tiles[id];
      if (!tile) continue;
      const poly = tilePolygons[id];
      if (!poly || poly.length < 3) continue;

      let shiftX = 0;
      if (pos.sx < wrapMargin) shiftX = worldWidth;
      else if (pos.sx > worldWidth - wrapMargin) shiftX = -worldWidth;
      else continue;

      tctx.beginPath();
      tctx.moveTo(poly[0][0] + shiftX, poly[0][1]);
      for (let i = 1; i < poly.length; i++) {
        tctx.lineTo(poly[i][0] + shiftX, poly[i][1]);
      }
      tctx.closePath();
      tctx.fillStyle = getTileColor(tile);
      tctx.fill();
    }
  }

  tctx.restore();

  equirectData = tctx.getImageData(0, 0, TEX_W, TEX_H);
  textureDirty = false;
}

// ============================================================
// Globe renderer (raycasting with texture sampling)
// ============================================================
function renderGlobe() {
  renderEquirectTexture();
  const useWeather = weatherEnabled && topologyType === 'Geodesic';
  if (useWeather) renderWeatherTexture();

  const canvasW = canvas.width;
  const canvasH = canvas.height;
  const cx = canvasW / 2;
  const cy = canvasH / 2;
  const r = Math.min(canvasW, canvasH) * 0.42 * zoom;
  const rAtm = useWeather ? r * 1.015 : r;  // atmosphere shell radius
  const rOuter = rAtm;  // bounding sphere for pixel loop

  ctx.clearRect(0, 0, canvasW, canvasH);
  ctx.fillStyle = '#0a0a1a';
  ctx.fillRect(0, 0, canvasW, canvasH);

  // Bounding box covers the larger atmosphere sphere
  const x0 = Math.max(0, Math.floor(cx - rOuter));
  const y0 = Math.max(0, Math.floor(cy - rOuter));
  const x1 = Math.min(canvasW, Math.ceil(cx + rOuter));
  const y1 = Math.min(canvasH, Math.ceil(cy + rOuter));
  const w = x1 - x0;
  const h = y1 - y0;
  if (w <= 0 || h <= 0) return;

  const imgData = ctx.createImageData(w, h);
  const pixels = imgData.data;
  const texPixels = equirectData.data;
  const wxPixels = (useWeather && weatherData) ? weatherData.data : null;

  const invR = 1 / r;
  const invRAtm = 1 / rAtm;
  const latRad = globeRotLat * Math.PI / 180;
  const lonRad = globeRotLon * Math.PI / 180;
  const cosLat = Math.cos(latRad);
  const sinLat = Math.sin(latRad);
  const cosLon = Math.cos(lonRad);
  const sinLon = Math.sin(lonRad);

  // Camera basis vectors (same for both spheres)
  const rx = -sinLon,          ry = cosLon,           rz = 0;
  const ux = -sinLat * cosLon, uy = -sinLat * sinLon, uz = cosLat;
  const fx = cosLat * cosLon,  fy = cosLat * sinLon,  fz = sinLat;

  const invPI = 1 / Math.PI;

  for (let py = y0; py < y1; py++) {
    const rowOff = (py - y0) * w;

    for (let px = x0; px < x1; px++) {
      const sx = px - cx;
      const sy = -(py - cy);

      // Terrain sphere test
      const nx_t = sx * invR;
      const ny_t = sy * invR;
      const distSq_t = nx_t * nx_t + ny_t * ny_t;
      const terrainHit = distSq_t <= 1;

      // Atmosphere sphere test
      const nx_a = sx * invRAtm;
      const ny_a = sy * invRAtm;
      const distSq_a = nx_a * nx_a + ny_a * ny_a;
      const atmosHit = wxPixels && distSq_a <= 1;

      if (!terrainHit && !atmosHit) continue;

      const outIdx = (rowOff + (px - x0)) * 4;

      // Sample terrain texture
      let tr = 0, tg = 0, tb = 0, tShade = 1;
      if (terrainHit) {
        const nz = Math.sqrt(1 - distSq_t);
        const wx = nx_t * rx + ny_t * ux + nz * fx;
        const wy = nx_t * ry + ny_t * uy + nz * fy;
        const wz = nx_t * rz + ny_t * uz + nz * fz;

        const lat = Math.asin(Math.max(-1, Math.min(1, wz)));
        const lon = Math.atan2(wy, wx);

        const texX = Math.max(0, Math.min(TEX_W - 1, ((lon * invPI + 1) * 0.5 * TEX_W) | 0));
        const texY = Math.max(0, Math.min(TEX_H - 1, ((0.5 - lat * invPI) * TEX_H) | 0));
        const texIdx = (texY * TEX_W + texX) * 4;

        tShade = 0.55 + 0.45 * nz;
        tr = texPixels[texIdx]     * tShade;
        tg = texPixels[texIdx + 1] * tShade;
        tb = texPixels[texIdx + 2] * tShade;
      }

      // Sample weather texture
      let wr = 0, wg = 0, wb = 0, wa = 0;
      if (atmosHit) {
        const nz = Math.sqrt(1 - distSq_a);
        const awx = nx_a * rx + ny_a * ux + nz * fx;
        const awy = nx_a * ry + ny_a * uy + nz * fy;
        const awz = nx_a * rz + ny_a * uz + nz * fz;

        const lat = Math.asin(Math.max(-1, Math.min(1, awz)));
        const lon = Math.atan2(awy, awx);

        const wtx = Math.max(0, Math.min(WTEX_W - 1, ((lon * invPI + 1) * 0.5 * WTEX_W) | 0));
        const wty = Math.max(0, Math.min(WTEX_H - 1, ((0.5 - lat * invPI) * WTEX_H) | 0));
        const wxIdx = (wty * WTEX_W + wtx) * 4;

        wr = wxPixels[wxIdx];
        wg = wxPixels[wxIdx + 1];
        wb = wxPixels[wxIdx + 2];
        wa = wxPixels[wxIdx + 3] / 255;
      }

      // Composite terrain + weather
      if (terrainHit) {
        // Cloud shadow darkens terrain
        const shadow = 1 - wa * 0.4;
        const sr = tr * shadow;
        const sg = tg * shadow;
        const sb = tb * shadow;

        // Alpha blend weather over shadowed terrain
        pixels[outIdx]     = sr * (1 - wa) + wr * wa;
        pixels[outIdx + 1] = sg * (1 - wa) + wg * wa;
        pixels[outIdx + 2] = sb * (1 - wa) + wb * wa;
        pixels[outIdx + 3] = 255;
      } else {
        // Atmosphere-only ring (thin edge between terrain and atmosphere)
        const edgeA = wa * 0.7;
        pixels[outIdx]     = wr * edgeA;
        pixels[outIdx + 1] = wg * edgeA;
        pixels[outIdx + 2] = wb * edgeA;
        pixels[outIdx + 3] = Math.round(edgeA * 255);
      }
    }
  }

  ctx.putImageData(imgData, x0, y0);

  // Atmosphere glow ring
  ctx.beginPath();
  ctx.arc(cx, cy, rAtm + 2, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(100, 160, 255, 0.3)';
  ctx.lineWidth = 3;
  ctx.stroke();

  ctx.beginPath();
  ctx.arc(cx, cy, rAtm + 5, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(80, 140, 255, 0.15)';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Pressure system H/L markers on globe (drawn on top of raycasted image)
  for (const sys of pressureSystems) {
    const tLat = sys.lat * Math.PI / 180;
    const tLon = sys.lon * Math.PI / 180;
    const twx = Math.cos(tLat) * Math.cos(tLon);
    const twy = Math.cos(tLat) * Math.sin(tLon);
    const twz = Math.sin(tLat);

    const snx = twx * rx + twy * ry + twz * rz;
    const sny = twx * ux + twy * uy + twz * uz;
    const snz = twx * fx + twy * fy + twz * fz;

    if (snz > 0.05) {
      const spx = cx + snx * r;
      const spy = cy - sny * r;
      const isLow = sys.pressure_anomaly < 0;

      ctx.fillStyle = isLow ? '#4488ff' : '#ff4444';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(isLow ? 'L' : 'H', spx, spy);
    }
  }

  // Selected tile highlight on globe
  if (selectedTile !== null && tiles[selectedTile]) {
    const tile = tiles[selectedTile];
    const tLat = (tile.position?.lat ?? 0) * Math.PI / 180;
    const tLon = (tile.position?.lon ?? 0) * Math.PI / 180;

    const twx = Math.cos(tLat) * Math.cos(tLon);
    const twy = Math.cos(tLat) * Math.sin(tLon);
    const twz = Math.sin(tLat);

    const snx = twx * rx + twy * ry + twz * rz;
    const sny = twx * ux + twy * uy + twz * uz;
    const snz = twx * fx + twy * fy + twz * fz;

    if (snz > 0) {
      const spx = cx + snx * r;
      const spy = cy - sny * r;
      ctx.beginPath();
      ctx.arc(spx, spy, 6, 0, Math.PI * 2);
      ctx.strokeStyle = '#e94560';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }
}

// ============================================================
// Globe click: pixel → tile
// ============================================================
function pixelToTileGlobe(px, py) {
  const canvasW = canvas.width;
  const canvasH = canvas.height;
  const cx = canvasW / 2;
  const cy = canvasH / 2;
  const r = Math.min(canvasW, canvasH) * 0.42 * zoom;

  const nx = (px - cx) / r;
  const ny = -(py - cy) / r;
  const distSq = nx * nx + ny * ny;
  if (distSq > 1) return null;

  const nz = Math.sqrt(1 - distSq);

  // Camera basis (same as renderGlobe)
  const latRad = globeRotLat * Math.PI / 180;
  const lonRad = globeRotLon * Math.PI / 180;
  const cosLat = Math.cos(latRad);
  const sinLat = Math.sin(latRad);
  const cosLon = Math.cos(lonRad);
  const sinLon = Math.sin(lonRad);

  const wx = nx * (-sinLon) + ny * (-sinLat * cosLon) + nz * (cosLat * cosLon);
  const wy = nx * (cosLon)  + ny * (-sinLat * sinLon) + nz * (cosLat * sinLon);
  const wz =                  ny * (cosLat)            + nz * (sinLat);

  // Find nearest tile using dot product with tile's 3D position
  let bestId = null;
  let bestDot = -Infinity;
  for (const [id, tile] of Object.entries(tiles)) {
    const p = tile.position;
    if (p.x == null) continue;
    const dot = wx * p.x + wy * p.y + wz * p.z;
    if (dot > bestDot) {
      bestDot = dot;
      bestId = parseInt(id);
    }
  }
  return bestId;
}

function render() {
  if (viewMode === 'globe') { renderGlobe(); return; }

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.translate(viewOffsetX, viewOffsetY);
  ctx.scale(zoom, zoom);

  const size = renderHexSize;
  const invZoom = 1 / zoom;
  const viewLeft = -viewOffsetX * invZoom - size * 2;
  const viewRight = (canvas.width - viewOffsetX) * invZoom + size * 2;
  const viewTop = -viewOffsetY * invZoom - size * 2;
  const viewBottom = (canvas.height - viewOffsetY) * invZoom + size * 2;
  const useVoronoi = topologyType === 'Geodesic';

  // Pass 1: terrain/data layer
  for (const [id, pos] of Object.entries(tilePositions)) {
    if (pos.sx < viewLeft || pos.sx > viewRight || pos.sy < viewTop || pos.sy > viewBottom) continue;

    const tile = tiles[id];
    if (!tile) continue;

    const baseColor = getTileColor(tile);
    const stroke = (parseInt(id) === selectedTile) ? '#e94560' : '#111';
    const poly = useVoronoi ? tilePolygons[id] : null;

    if (poly) {
      drawPolygon(poly, baseColor, stroke);
    } else {
      drawHex(pos.sx, pos.sy, size * 0.95, baseColor, stroke);
    }

    if (parseInt(id) === selectedTile) {
      if (poly) {
        drawPolygon(poly, 'transparent', '#e94560');
      } else {
        drawHex(pos.sx, pos.sy, size * 0.95, 'transparent', '#e94560');
      }
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }

  // Pass 1b: wrapped copies at antimeridian
  if (useVoronoi && geoScaleValue > 0) {
    const worldWidth = 360 * geoScaleValue;
    const wrapMargin = worldWidth * 0.15;
    for (const [id, pos] of Object.entries(tilePositions)) {
      let shiftX = 0;
      if (pos.sx < wrapMargin) shiftX = worldWidth;
      else if (pos.sx > worldWidth - wrapMargin) shiftX = -worldWidth;
      else continue;

      const shiftedX = pos.sx + shiftX;
      if (shiftedX < viewLeft || shiftedX > viewRight) continue;

      const tile = tiles[id];
      if (!tile) continue;
      const poly = tilePolygons[id];
      if (!poly || poly.length < 3) continue;

      const baseColor = getTileColor(tile);
      const stroke = (parseInt(id) === selectedTile) ? '#e94560' : '#111';

      const shifted = poly.map(p => [p[0] + shiftX, p[1]]);
      drawPolygon(shifted, baseColor, stroke);
    }
  }

  // Pass 2: weather overlay (clouds, precipitation, storms)
  if (weatherEnabled) {
    for (const [id, pos] of Object.entries(tilePositions)) {
      if (pos.sx < viewLeft || pos.sx > viewRight || pos.sy < viewTop || pos.sy > viewBottom) continue;

      const tile = tiles[id];
      if (!tile) continue;

      const wx = computeWeatherRGBA(tile);
      if (wx.a === 0) continue;

      const overlay = `rgba(${wx.r},${wx.g},${wx.b},${(wx.a / 255).toFixed(3)})`;
      const poly = useVoronoi ? tilePolygons[id] : null;

      if (poly) {
        drawPolygon(poly, overlay, null);
      } else {
        drawHex(pos.sx, pos.sy, size * 0.95, overlay, null);
      }
    }

    // Weather overlay for wrapped copies
    if (useVoronoi && geoScaleValue > 0) {
      const worldWidth = 360 * geoScaleValue;
      const wrapMargin = worldWidth * 0.15;
      for (const [id, pos] of Object.entries(tilePositions)) {
        let shiftX = 0;
        if (pos.sx < wrapMargin) shiftX = worldWidth;
        else if (pos.sx > worldWidth - wrapMargin) shiftX = -worldWidth;
        else continue;

        const shiftedX = pos.sx + shiftX;
        if (shiftedX < viewLeft || shiftedX > viewRight) continue;

        const tile = tiles[id];
        if (!tile) continue;
        const poly = tilePolygons[id];
        if (!poly || poly.length < 3) continue;

        const wx = computeWeatherRGBA(tile);
        if (wx.a === 0) continue;

        const shifted = poly.map(p => [p[0] + shiftX, p[1]]);
        drawPolygon(shifted, `rgba(${wx.r},${wx.g},${wx.b},${(wx.a / 255).toFixed(3)})`, null);
      }
    }
  }

  ctx.restore();

  // Draw pressure system overlays on the map
  drawPressureSystemsMap();
}

// ============================================================
// Pressure system overlay (map view)
// ============================================================
function drawPressureSystemsMap() {
  if (pressureSystems.length === 0) return;
  if (topologyType !== 'Geodesic' || !geoScaleValue) return;

  ctx.save();
  ctx.translate(viewOffsetX, viewOffsetY);
  ctx.scale(zoom, zoom);

  for (const sys of pressureSystems) {
    const sx = (sys.lon + 180) * geoScaleValue;
    const sy = (90 - sys.lat) * geoScaleValue;
    const radiusPx = sys.radius * (180 / Math.PI) * geoScaleValue; // radians -> degrees -> pixels

    const isLow = sys.pressure_anomaly < 0;
    const color = isLow ? 'rgba(60, 100, 220, 0.25)' : 'rgba(220, 60, 60, 0.25)';
    const borderColor = isLow ? 'rgba(60, 100, 220, 0.6)' : 'rgba(220, 60, 60, 0.6)';

    // Semi-transparent influence circle
    ctx.beginPath();
    ctx.arc(sx, sy, radiusPx, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = 1.5 / zoom;
    ctx.stroke();

    // Center marker with H/L label
    ctx.fillStyle = isLow ? '#4488ff' : '#ff4444';
    ctx.font = `bold ${Math.max(10, 14 / zoom)}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(isLow ? 'L' : 'H', sx, sy);

    // Pressure value
    ctx.fillStyle = '#ccc';
    ctx.font = `${Math.max(8, 10 / zoom)}px sans-serif`;
    ctx.fillText(`${(1013.25 + sys.pressure_anomaly).toFixed(0)}`, sx, sy + 14 / zoom);
  }

  ctx.restore();
}

// ============================================================
// Interaction (pan, zoom, click)
// ============================================================
container.addEventListener('mousedown', (e) => {
  isDragging = true;
  dragStartX = e.clientX;
  dragStartY = e.clientY;
  dragStartOffsetX = viewOffsetX;
  dragStartOffsetY = viewOffsetY;
  dragStartRotLon = globeRotLon;
  dragStartRotLat = globeRotLat;
  container.classList.add('dragging');
});

window.addEventListener('mousemove', (e) => {
  if (!isDragging) return;
  const dx = e.clientX - dragStartX;
  const dy = e.clientY - dragStartY;

  if (viewMode === 'globe') {
    globeRotLon = dragStartRotLon - dx * 0.3;
    globeRotLat = Math.max(-89, Math.min(89, dragStartRotLat + dy * 0.3));
  } else {
    viewOffsetX = dragStartOffsetX + dx;
    viewOffsetY = dragStartOffsetY + dy;
  }
  render();
});

window.addEventListener('mouseup', (e) => {
  if (!isDragging) return;
  const moved = Math.abs(e.clientX - dragStartX) + Math.abs(e.clientY - dragStartY);
  isDragging = false;
  container.classList.remove('dragging');

  // If barely moved, treat as click
  if (moved < 4) {
    const rect = canvas.getBoundingClientRect();
    const px = e.clientX - rect.left;
    const py = e.clientY - rect.top;
    const tileId = (viewMode === 'globe') ? pixelToTileGlobe(px, py) : pixelToTile(px, py);
    selectTile(tileId);
  }
});

container.addEventListener('wheel', (e) => {
  e.preventDefault();
  const delta = e.deltaY > 0 ? 0.9 : 1.1;

  if (viewMode === 'globe') {
    // Globe zoom: scale the globe radius via zoom, no pan offset changes
    zoom = Math.max(0.3, Math.min(5, zoom * delta));
  } else {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const oldZoom = zoom;
    zoom = Math.max(0.1, Math.min(10, zoom * delta));

    // Zoom toward cursor
    viewOffsetX = mx - (mx - viewOffsetX) * (zoom / oldZoom);
    viewOffsetY = my - (my - viewOffsetY) * (zoom / oldZoom);
  }

  render();
}, { passive: false });

document.getElementById('color-select').addEventListener('change', (e) => {
  colorMode = e.target.value;
  textureDirty = true;
  render();
});

document.getElementById('weather-enabled').addEventListener('change', (e) => {
  weatherEnabled = e.target.checked;
  weatherDirty = true;
  textureDirty = true;
  render();
});

document.getElementById('view-select').addEventListener('change', (e) => {
  viewMode = e.target.value;
  if (viewMode === 'globe') {
    textureDirty = true;
    zoom = 1; // reset zoom for globe
  }
  render();
});

// ============================================================
// Tile selection
// ============================================================
function selectTile(id) {
  selectedTile = id;
  const info = document.getElementById('tile-info');
  const detail = document.getElementById('tile-detail');

  if (id === null || !tiles[id]) {
    info.classList.remove('visible');
    render();
    return;
  }

  const t = tiles[id];
  info.classList.add('visible');
  detail.innerHTML = `
    <div class="stat-row"><span class="label">ID</span><span class="value">${t.id}</span></div>
    ${topologyType === 'Geodesic' ? `
    <div class="stat-row"><span class="label">Lat</span><span class="value">${t.position?.lat?.toFixed(2)}&deg;</span></div>
    <div class="stat-row"><span class="label">Lon</span><span class="value">${t.position?.lon?.toFixed(2)}&deg;</span></div>
    ` : ''}
    <div class="layer-title">Geology</div>
    <div class="stat-row"><span class="label">Terrain</span><span class="value">${t.geology?.terrain_type}</span></div>
    <div class="stat-row"><span class="label">Elevation</span><span class="value">${t.geology?.elevation?.toFixed(3)}</span></div>
    <div class="stat-row"><span class="label">Soil</span><span class="value">${t.geology?.soil_type}</span></div>
    <div class="layer-title">Climate</div>
    <div class="stat-row"><span class="label">Zone</span><span class="value">${t.climate?.zone}</span></div>
    <div class="stat-row"><span class="label">Base Temp</span><span class="value">${t.climate?.base_temperature?.toFixed(1)}K</span></div>
    <div class="layer-title">Biome</div>
    <div class="stat-row"><span class="label">Type</span><span class="value">${t.biome?.biome_type}</span></div>
    <div class="stat-row"><span class="label">Veg Health</span><span class="value">${t.biome?.vegetation_health?.toFixed(3)}</span></div>
    <div class="stat-row"><span class="label">Veg Density</span><span class="value">${t.biome?.vegetation_density?.toFixed(3)}</span></div>
    <div class="layer-title">Weather</div>
    <div class="stat-row"><span class="label">Temp</span><span class="value">${t.weather?.temperature?.toFixed(1)}K (${(t.weather?.temperature - 273.15)?.toFixed(1)}&deg;C)</span></div>
    <div class="stat-row"><span class="label">Precip</span><span class="value">${t.weather?.precipitation?.toFixed(3)} (${t.weather?.precipitation_type})</span></div>
    <div class="stat-row"><span class="label">Wind</span><span class="value">${t.weather?.wind_speed?.toFixed(1)} @ ${t.weather?.wind_direction?.toFixed(0)}&deg;</span></div>
    <div class="stat-row"><span class="label">Clouds</span><span class="value">${t.weather?.cloud_cover?.toFixed(3)}</span></div>
    <div class="stat-row"><span class="label">Humidity</span><span class="value">${t.weather?.humidity?.toFixed(3)}</span></div>
    <div class="stat-row"><span class="label">Pressure</span><span class="value">${t.weather?.pressure?.toFixed(1) ?? '1013.3'} hPa</span></div>
    <div class="stat-row"><span class="label">Storm</span><span class="value">${t.weather?.storm_intensity?.toFixed(3)}</span></div>
    <div class="stat-row"><span class="label">Macro Wind</span><span class="value">${t.weather?.macro_wind_speed?.toFixed(1) ?? '0.0'} @ ${t.weather?.macro_wind_direction?.toFixed(0) ?? '0'}&deg;</span></div>
    <div class="layer-title">Conditions</div>
    <div class="stat-row"><span class="label">Moisture</span><span class="value">${t.conditions?.soil_moisture?.toFixed(3)}</span></div>
    <div class="stat-row"><span class="label">Snow</span><span class="value">${t.conditions?.snow_depth?.toFixed(3)}</span></div>
    <div class="stat-row"><span class="label">Fire Risk</span><span class="value">${t.conditions?.fire_risk?.toFixed(3)}</span></div>
  `;
  render();
}

// ============================================================
// Stats panel
// ============================================================
function updateStats(s) {
  stats = s;
  document.getElementById('stat-tick').textContent = s.tick ?? '-';
  document.getElementById('stat-diversity').textContent = s.diversity_index?.toFixed(3) ?? '-';
  document.getElementById('stat-temp').textContent =
    s.avg_temperature ? `${s.avg_temperature.toFixed(1)}K (${(s.avg_temperature - 273.15).toFixed(1)}\u00B0C)` : '-';
  document.getElementById('stat-moisture').textContent = s.avg_moisture?.toFixed(3) ?? '-';
  document.getElementById('stat-tickms').textContent = s.tick_duration_ms ? `${s.tick_duration_ms.toFixed(1)}ms` : '-';
  document.getElementById('stat-errors').textContent = s.rule_errors ?? '-';

  // Biome distribution bar
  if (s.biome_distribution) {
    const total = Object.values(s.biome_distribution).reduce((a, b) => a + b, 0);
    const bar = document.getElementById('biome-bar');
    const legend = document.getElementById('biome-legend');
    let barHtml = '';
    let legendHtml = '';
    const sorted = Object.entries(s.biome_distribution).sort((a, b) => b[1] - a[1]);
    for (const [biome, count] of sorted) {
      const pct = (count / total * 100);
      const color = BIOME_COLORS[biome] || '#444';
      barHtml += `<div class="biome-segment" style="width:${pct}%;background:${color}" title="${biome}: ${pct.toFixed(1)}%"></div>`;
      legendHtml += `<span class="biome-legend-item"><span class="biome-legend-swatch" style="background:${color}"></span>${biome}</span>`;
    }
    bar.innerHTML = barHtml;
    legend.innerHTML = legendHtml;
  }
}

// ============================================================
// WebSocket connection
// ============================================================
function connect() {
  // When served by the engine, use the same host:port. When opened as a file, fall back to query param.
  const host = location.hostname || 'localhost';
  const port = location.port || new URLSearchParams(location.search).get('port') || '8118';
  const url = `ws://${host}:${port}`;

  setStatus('connecting');
  ws = new WebSocket(url);

  ws.onopen = () => setStatus('connected');

  ws.onclose = () => {
    setStatus('disconnected');
    setTimeout(connect, 2000);
  };

  ws.onerror = () => setStatus('disconnected');

  ws.onmessage = (event) => {
    const msg = JSON.parse(event.data);

    if (msg.message_type === 'WorldSnapshot') {
      handleSnapshot(msg);
    } else if (msg.message_type === 'TickDiff') {
      handleDiff(msg);
    }
  };
}

function setStatus(state) {
  const el = document.getElementById('connection-status');
  el.className = `status-${state}`;
  el.textContent = state === 'connected' ? 'Connected' :
                    state === 'connecting' ? 'Connecting...' : 'Disconnected';
}

function handleSnapshot(msg) {
  tiles = {};
  tilePositions = {};

  topologyType = msg.topology_type || 'FlatHex';
  document.getElementById('stat-season').textContent = msg.season;
  document.getElementById('stat-tiles').textContent = msg.tile_count;
  document.getElementById('stat-tick').textContent = msg.tick;
  document.getElementById('stat-topology').textContent = topologyType;

  // Compute grid bounds for centering
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

  const geoScale = hexSize * 2; // ~24 px/degree for equirectangular projection
  geoScaleValue = geoScale;

  for (const t of msg.tiles) {
    tiles[t.id] = t;
    let sx, sy;
    if (topologyType === 'Geodesic') {
      // Equirectangular projection: lon → x, lat → y
      sx = (t.position.lon + 180) * geoScale;
      sy = (90 - t.position.lat) * geoScale;
    } else {
      sx = t.position.x * hexSize;
      sy = t.position.y * hexSize;
    }
    tilePositions[t.id] = { sx, sy };
    minX = Math.min(minX, sx);
    maxX = Math.max(maxX, sx);
    minY = Math.min(minY, sy);
    maxY = Math.max(maxY, sy);
  }

  // Compute render hex size and Voronoi cells for geodesic
  if (topologyType === 'Geodesic') {
    const tileCount = msg.tiles.length;
    const angularSpacing = Math.sqrt(4 * Math.PI / tileCount) * (180 / Math.PI); // degrees
    renderHexSize = angularSpacing * geoScale * 0.55; // pixels, for frustum culling margin
    computeVoronoiCells();
  } else {
    renderHexSize = hexSize;
    tilePolygons = {};
  }

  // Show/hide globe toggle based on topology
  document.getElementById('view-mode').style.display =
    (topologyType === 'Geodesic') ? 'block' : 'none';
  if (topologyType !== 'Geodesic' && viewMode === 'globe') {
    viewMode = 'map';
    document.getElementById('view-select').value = 'map';
  }

  // Parse pressure systems
  pressureSystems = msg.pressure_systems || [];

  textureDirty = true;
  weatherDirty = true;

  // Center view (for map mode)
  const worldW = maxX - minX;
  const worldH = maxY - minY;
  if (viewMode !== 'globe') {
    zoom = Math.min(canvas.width / (worldW + renderHexSize * 4), canvas.height / (worldH + renderHexSize * 4));
    zoom = Math.max(0.1, Math.min(5, zoom));
    viewOffsetX = (canvas.width - worldW * zoom) / 2 - minX * zoom;
    viewOffsetY = (canvas.height - worldH * zoom) / 2 - minY * zoom;
  }

  render();
}

function handleDiff(msg) {
  document.getElementById('stat-tick').textContent = msg.tick;
  document.getElementById('stat-season').textContent = msg.season;

  // Apply changes
  for (const change of msg.changed_tiles) {
    const t = tiles[change.id];
    if (!t) continue;
    if (change.weather) t.weather = change.weather;
    if (change.conditions) t.conditions = change.conditions;
    if (change.biome) t.biome = change.biome;
    if (change.resources) t.resources = change.resources;
  }

  // Update pressure systems from diff
  if (msg.pressure_systems) {
    pressureSystems = msg.pressure_systems;
  }

  textureDirty = true;
  weatherDirty = true;

  if (msg.statistics) {
    updateStats(msg.statistics);
  }

  // Update selected tile display if visible
  if (selectedTile !== null && tiles[selectedTile]) {
    selectTile(selectedTile);
  } else {
    render();
  }
}

// ============================================================
// Init
// ============================================================
resizeCanvas();
connect();
</script>
</body>
</html>
